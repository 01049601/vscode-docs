---
Order: 82
TOCTitle: October 2022
PageTitle: Visual Studio Code October 2022
MetaDescription: Learn what is new in the Visual Studio Code October 2022 Release (1.73)
MetaSocialImage: 1_73/release-highlights.png
Date: 2022-11-3
DownloadVersion: 1.73.0
---
# October 2022 (version 1.73)

<!-- DOWNLOAD_LINKS_PLACEHOLDER -->

Welcome to the Insiders build. These are the preliminary notes for the October 1.73 release of Visual Studio Code. As we get closer to the release date, you'll find details below about new features and important fixes.

Until the October milestone release notes are available, you can still track our progress:

* **[Commit log](https://github.com/Microsoft/vscode/commits/main)** - GitHub commits to the vscode open-source repository.
* **[Closed issues](https://github.com/Microsoft/vscode/issues?q=is%3Aissue+milestone%3A%22October+2022%22+is%3Aclosed)** - Resolved bugs and implemented feature requests in the milestone.

We really appreciate people trying our new features as soon as they are ready, so check back here often and learn what's new.

>If you'd like to read release notes for previous VS Code versions, go to [Updates](https://code.visualstudio.com/updates) on [code.visualstudio.com](https://code.visualstudio.com).

## Workbench

### Command Center Home

A "home" view was added to the Command Center to make it easy to discover how to navigate to files, run commands, and more.

This short list of modes also provides keybinding hints so that you can jump directly to your most-used modes (for example **Go to File**) without going through the Command Center.

<video src="images/1_73/command-center-home.mp4" placeholder="images/1_73/command-center-home.mp4" autoplay loop controls muted title="Command Center Home View">
    Sorry, your browser doesn't support HTML 5 video.
</video>

### Settings editor Workspace Trust and policy indicators

Settings that are not applied due to a Restricted Mode workspace or due to being managed under an organization policy now use indicators to display their status. The user can read and write workspace settings even in a Restricted Mode workspace (which was always possible using the `settings.json` file), but the workspace setting value won't be considered when calculating the final value of the setting to use in a restricted workspace.

There have also been a few adjustments to the default light theme, with clearer codicon rendering in the indicators area and tighter focus borders.

![Restricted workspace settings demo showing keyboard navigation and toggling a checkbox even when the setting is restricted](images/1_73/settings-editor-indicators-keyboard.gif)

### Accessibility setting tag

An `accessibility` tag can now be used to improve discoverability of accessibility related settings.

The **Preferences: Open Accessibility Settings** command opens the Settings editor with the `@tag:accessibility` filter.

### Outline default collapse state

There is a new setting `outline.collapseItems` that controls the default collapse state of Outline items. The default value is `false`, which means that Outline items are expanded by default. Set it to `true` to have Outline items collapsed by default. This setting can be set per language and also works for notebooks.

### Shortcuts for including/excluding folders from Search results

When right-clicking a folder in the Search view's search results, there are now two new options in the context menu.

* Selecting **Restrict Search to Folder** adds the selected folder path(s) to the **files to include** textbox. Adding a path to this textbox will limit search results to ones that fit the listed paths or patterns.

![Using Restrict Search to Folder](images/1_73/restrict-search-to-folder.gif)
_Theme: [GitHub Dark Dimmed](https://marketplace.visualstudio.com/items?itemName=GitHub.github-vscode-theme)_

* Selecting **Exclude Folder from Search** adds the selected folder path(s) to the **files to exclude** textbox. Adding a path here will exclude any search results that fit the listed paths or patterns.

![Using Exclude Folder from Search](images/1_73/exclude-folder-from-search.gif)
_Theme: [GitHub Dark Dimmed](https://marketplace.visualstudio.com/items?itemName=GitHub.github-vscode-theme)_

### Rearrange the View menu

In the View menu of the application menubar, the final group was a growing list of editor actions. As a means to balance growth of the menu and functionality, we have moved the primarily appearance-related items under the Appearance submenu. Word Wrap and Sticky Scroll have been left in their original positions.

![Updated View Menu](images/1_73/new-view-menu.png)

_Theme: [GitHub Light Default](https://marketplace.visualstudio.com/items?itemName=GitHub.github-vscode-theme)_

### Rounded corners on input UI

Text inputs, text areas, and dropdowns all now feature rounded corners to match the same styling applied to buttons in a previous release.

![Text input with rounded corners](images/1_73/rounded-corners-inputs.png)

### Quick Pick list style updates

The list styling used in the Quick Pick UI has been lightly refreshed with rounded corners and left/right margin.

<video src="images/1_73/quick-pick-list-styles.mp4" placeholder="images/1_73/quick-pick-list-styles.mp4" autoplay loop controls muted title="Quick Pick List Styles">
    Sorry, your browser doesn't support HTML 5 video.
</video>

### Updated Codicons for list views

Flat list and tree list views now use more legible [codicons](https://github.com/microsoft/vscode-codicons).

<video src="images/1_73/list-icon-styles.mp4" placeholder="images/1_73/list-icon-styles.mp4" autoplay loop controls muted title="Update list view icons">
    Sorry, your browser doesn't support HTML 5 video.
</video>

### Secondary Side Bar foreground color

The Secondary Side Bar mimics the theming of the Primary Side Bar in general, but not all theme keys were being picked up properly. The Secondary Side Bar now properly uses the `"sideBar.foreground"` theme key.

![Secondary Side Bar Foreground](images/1_73/secondary-sidebar-foreground.png)

_Theme: [GitHub Light Default](https://marketplace.visualstudio.com/items?itemName=GitHub.github-vscode-theme)_

### No more 'Too many folding ranges' notifications

For performance reasons, we limit the number of folding ranges shown in the editor to 5000. The limit can be configured by the setting `editor.foldingMaximumRegions`.
When the limit is exceeded we used to show a notification. Instead we now use the language status to show the information.

![folding limit warning in the language status](images/1_73/folding-limit-warning.png)

### Default folding provider

Normally, when there are multiple folding providers active for a language, VS Core tries to merge the result. If there are conflicting ranges, some ranges are discarded. In addition, not all folding providers can be combined with others providers.

The new `editor.defaultFoldingProvider` setting allows you to select the folding provider to use. The name of the provider is the extension ID (`{publisher}.{extension}`) of the extension that provides it.

The following example sets the folding provider from the (hypothetical) extension `aeschli.better-folding` to be the default for JavaScript.

```json
    "[javascript]": {
            "editor.defaultFoldingRangeProvider": "aeschli.better-folding"
    }
```

### Word wrapping in accessibility mode

Historically, word wrapping was disabled outright when in accessibility mode to prevent a degraded screen reader experience. This has been fixed and can be enabled via `editor.wordWrap`.

## Languages

### Markdown automatic link updates on file rename / move

Tired of accidentally breaking links or images in your Markdown when you move or rename files? Try the new `markdown.updateLinksOnFileMove.enabled` setting!

With this new setting enabled, VS Code will automatically update links and images in Markdown when files are moved or renamed in the VS Code Explorer:

![Markdown file links are updated on move and rename](images/1_73/md-link-update.gif)

You can control the types of files affected using `markdown.updateLinksOnFileMove.include`. By default, it is enabled for all Markdown files and common image file formats.

### Markdown insert link commands

The new  `Markdown: Insert Link to File in Workspace` and `Markdown: Insert Image from Workspace` commands let you quickly insert links and images to your Markdown using a file picker:

<video src="images/1_73/md-insert-image.mp4" autoplay loop controls muted title="Markdown insert link commands">
    Sorry, your browser doesn't support HTML 5 video.
</video>

Remember that this is just one option for adding links and images to your Markdown. You can also use [Markdown path completions](/docs/languages/markdown.md#path-completions) for this or even [drag and drop files from VS Code's explorer](/docs/languages/markdown.md#drag-and-drop-to-insert-links-and-images) to insert links or images.

### Markdown unused and duplicate link definition diagnostics

Our built-in Markdown validation can now alert to used or duplicated [link definitions](https://daringfireball.net/projects/markdown/syntax#link). You can enable this feature with `markdown.validate.enabled`:

![An warning about a duplicate link definition](images/1_73/md-duplicate-link-def.png)

If you want finer grained control of these errors, you can use the `markdown.validate.duplicateLinkDefinitions.enabled` and `markdown.validate.unusedLinkDefinitions.enabled` settings to either disable these errors or change their severity.

We also include a quick fix to remove duplicated or unused link definitions.

### Markdown link occurrence highlighting

Link occurrence highlighting in Markdown shows you all the places in the current document where the link under the cursor is being used:

![Highlighting all occurrences of a link](images/1_73/md-link-highlight.png)

Notice how with the cursor on the the first link in the document, all links to `First Header` as well as the header itself are highlighted in the document and in the gutter to the right of the document.

This feature is off by default. To enable it, turn on the `markdown.occurrencesHighlight.enabled` setting.

### New Razor syntax highlighting grammar

VS Code has a new, better-maintained, [Razor](https://learn.microsoft.com/aspnet/core/razor-pages) grammar for syntax highlighting of Razor files. The new grammar is actively maintained and fixes issues that existed in the old grammar.

## VS Code for the Web

### Improved branch creation and protection workflows

When you are in a GitHub or Azure Repos repository on VS Code for the Web, committing to a protected branch now notifies you that the current branch is protected, and prompts you to create a new branch.

This flow will also honor the following settings:

* `git.branchPrefix` allows you to prepopulate the branch name quick input with a configured prefix
* `"git.branchProtectionPrompt": "alwaysCommitToNewBranch"` allows you to skip the prompt when you attempt to commit to a protected branch and go straight to the quick input for creating a new branch

In addition, when you create a new branch, you can bypass the prompt about whether to switch to the newly created branch by configuring `"remoteHub.switchToCreatedBranch": "always"`.

All of the above also applies when using the [GitHub Repositories](https://marketplace.visualstudio.com/items?itemName=GitHub.remotehub) or [Azure Repos](https://marketplace.visualstudio.com/items?itemName=ms-vscode.remote-repositories) extensions on VS Code for the desktop.

### Localization Improvements in the web

A few months ago we started working on localization in the web. Up until now, VS Code core and extensions with statically declared strings in their extension manifests were able to be localized. This iteration, we've finished the final piece of the puzzle: strings in extension code. This is checked off due to the finalization of the localization API that we [proposed last month](https://code.visualstudio.com/updates/v1_72#_localization-as-part-of-the-api).

Be on the lookout for more of VS Code becoming localized as we continue to adopt this new API in all of our extensions. If you're an extension author, you can learn more about the new API in the [vscode-l10n repository](https://github.com/microsoft/vscode-l10n).

## Contributions to extensions

### Python

#### Migration to isort extension

In our May 2022 [release](https://devblogs.microsoft.com/python/python-in-visual-studio-code-may-2022-release/), we announced a new [isort](https://marketplace.visualstudio.com/items?itemName=ms-python.isort) extension that works alongside the Python extension to sort imports. For example, when you open a file and the imports do not follow isort's standards, it will display an error diagnostic and provide a Code Action to fix the import order. In this release, we are migrating to use the isort extension instead of isort built-in to the Python extension by automatically installing it alongside the Python extension.

#### Auto imports turned off by default with Pylance

Since auto imports were first implemented in Pylance, we've been getting a lot of feedback about how confusing and, sometimes, annoying it can be to have an import automatically added to a file when, for example, suggestions are accepted by accident. Starting this release, packages will no longer be imported automatically by default when using Pylance. If you'd like to re-enable auto imports for your Python projects, you can do so by setting `"python.analysis.autoImportCompletions": false`.

#### Pylint and flake8 extensions recommendation

In our [previous](https://devblogs.microsoft.com/python/python-in-visual-studio-code-april-2022-release/#pylint-extension) [releases](https://devblogs.microsoft.com/python/pvsc-sept-2022/#flake8-extension), we announced new [Pylint](https://marketplace.visualstudio.com/items?itemName=ms-python.pylint) and [Flake8](https://marketplace.visualstudio.com/items?itemName=ms-python.flake8) extensions that work in tandem with the Python extension through the Language Server Protocol (LSP) to provide linting. In this release, we display a notification for those still using the Pylint and flake8 features in the Python extension to install these new extensions, as they are our long term planned support for linting.

![Use and install the Pylint extension prompt](images/1_73/Nov2022-PylintPrompt.png)

### Jupyter

#### Respect the "Just My Code" setting for notebook cell debugging

The "Just My Code" debug feature allows the user to determine whether the debugger will step through code from Python libraries, or will only step through user code. This is enabled by default, and you can now set `"jupyter.debugJustMyCode": false` to disable it and allow stepping through library code. For the best experience, upgrade debugpy in your environment to `1.6.3+`. Previously, this setting was only respected for debugging using the Interactive Window. Now it is respected in notebook editors as well.

#### Support restarting notebook cell debug sessions

The "Restart" command in the debug toolbar restarts the current debug session. Previously this threw an error in notebook debug sessions, but now it is supported in the notebook editor. Unfortunately it can't be properly supported in the Interactive Window.

This feature is especially useful in a workflow where you debug, edit the cell, then restart the debug session to debug the cell again with your edits applied.

### GitHub Pull Requests and Issues

Work continues on the [GitHub Pull Requests and Issues](https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-pull-request-github) extension, which allows you to work on, create, and manage pull requests and issues. Check out the [changelog for the 0.54.0](https://github.com/microsoft/vscode-pull-request-github/blob/main/CHANGELOG.md#0540) release of the extension to see the other highlights.

## Preview features

### TypeScript 4.9

This update includes support for the upcoming TypeScript 4.9 release. See the [TypeScript 4.9 iteration plan](https://github.com/microsoft/TypeScript/issues/504574) for more details on what the TypeScript team is currently working on. Some editor tooling highlights:

* A new **Sort Imports** command that sorts imports without removing unused ones.
* Running **Go to Definition** on a return statement [now jumps to the function declaration](https://github.com/microsoft/TypeScript/issues/51222).
* Switch to a [new default file watcher](https://devblogs.microsoft.com/typescript/announcing-typescript-4-9-beta/#file-watching-now-uses-file-system-events), which should perform better.

To start using the TypeScript 4.9 nightly builds, install the [TypeScript Nightly](https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-typescript-next) extension.

## Extension authoring

### Provide metadata for workspace edits

The API to apply a workspace edit now lets extensions provide metadata, for example for marking the edit as being a refactoring. This extra metadata will be honored by the editor and Auto Save after refactoring (setting: `files.refactoring.autoSave`).

### Restrict which commands can be run by MarkdownString and in webviews

[Command links](https://code.visualstudio.com/api/extension-guides/command#command-uris) in `MarkdownString` are a useful way to create custom interactions in VS Code's hovers message or IntelliSense details. Webviews can also use command links to trigger VS Code commands directly from the webview. However command links can also be dangerous as they can be used to execute any command, including many commands which were not designed with security in mind. For this reason, command links are disabled by default and must explicitly be enabled by extensions.

While this all-or-nothing approach works, we've also found it places too much of the security burden on extension authors. Extensions that need to use command links must validate that only safe command are included in the content they render. This is both easy to forget and easy to get wrong.

To improve this, we're introducing new APIs for command link enablement that allow extensions to enable just a trusted subset of commands.

For `MarkdownString`, the `isTrusted` property now takes an allowlist of commands that can be executed (all other commands will be blocked):

```ts
const md = new vscode.MarkdownString(`A command link: [Open setting](command:workbench.action.openSettings)`);

// Set trusted commands instead of enabling all commands
md.isTrusted = { enabledCommands: ['workbench.action.openSettings'] };
```

For webviews, the `WebviewOptions.enableCommandUris` property can now be a list of enabled commands instead of a simple true/false:

```ts
const options: vscode.WebviewOptions = { enableCommandUris: ['workbench.action.openSettings'] };
```

We highly encourage that all extension that use command links adopt this new, more restrictive api to improve security.

### Consistent origin for webviews and webview views

To improve the loading time of [webviews](/api/extension-guides/webview.md), we now try to maintain a consistent origin for all instances of a given type of webview. This has two main benefits:

- Webviews can better take advantage of caching. This means local resources should load faster.

- Webviews can use local storage and other web apis that are partitioned per origin.

    Keep in mind that all instances of a webview will now run on the same origin so if are using an API such as local storage, be sure to partition any data/state that is document specific per resource. For example, `localStorage.setItem('scrollPosition', 100)` will set `scrollPosition` to 100 across all webview instances. If you want to set the scroll position for individual resources, you also need to include the resource id in the key: `localStorage.setItem(myDocUri, JSON.stringify({scrollPosition: 100 }))`.

    You should also never use localStorage or similar apis to store critical data, such a document contents. While VS Code makes a best effort to maintain consistent origin for webviews, we cannot guarantee the origin will not change.

    In many cases, you should use the [webview state apis](/api/extension-guides/webview.md#getstate-and-setstate) as these api handle both of the above problems for you.

The origin is randomly generated for each extension and type of webview. The same origin is used across all instances of the webview.

Currently both normal [webviews](/api/extension-guides/webview.md) and [webview views](https://github.com/microsoft/vscode-extension-samples/tree/main/webview-view-sample) try to maintain a consistent origin. We plan on adopting this for custom editors and notebook webviews next iteration.

## Debug Adapter Protocol

### New 'startDebugging' reverse request

Today VS Code supports multiple concurrent debug sessions but the [Debug Adapter Protocol](https://microsoft.github.io/debug-adapter-protocol) (DAP) covers only a single session. That means that creating new debug sessions programmatically is not part of DAP and can only be done outside of DAP or the debug adapter, typically in the debug extension that contains the debug adapter. As a consequence, multi-session functionality such as automatically debugging child-processes is not easily available for non-VS Code DAP clients, because they typically use only the debug adapter and not the VS Code specific debug extension.

To improve this situation, we have added a new reverse request `startDebugging` to DAP that allows to create a new debug session (of the same type as the caller) from **within** the debug adapter. A client capability `supportsStartDebuggingRequest` indicates to a debug adapter that the client supports `startDebugging`.

In the October release, VS Code has implemented `startDebugging`.

## Proposed APIs

Every milestone comes with new proposed APIs and extension authors can try them out. As always, we want your feedback. Here are the steps to try out a proposed API:

1. [Find a proposal that you want to try](https://github.com/microsoft/vscode/tree/main/src/vscode-dts) and add its name to `package.json#enabledApiProposals`.
1. Use the latest [vscode-dts](https://www.npmjs.com/package/vscode-dts) and run `vscode-dts dev`. It will download the corresponding `d.ts` files into your workspace.
1. You can now program against the proposal.

You cannot publish an extension that uses a proposed API. There may be breaking changes in the next release and we never want to break existing extensions.

### Static notebook preloads

The new `notebookPreload` proposed contribution point lets extensions contribute scripts that are loaded into notebooks of a specific type.

```jsonc
{
    "contributes": {
        "notebookPreload": [
            {
                "type": "jupyter-notebook", // Type of notebook the preload script should be enabled for
                "entrypoint": "./path/to/preload.js"
            }
        ]
    }
}
```

This contribution point is controlled by the `contribNotebookStaticPreloads` api proposal. Extensions can use preloads to load or define globals in the notebook JavaScript environment.

The preload script must be a JavaScript module that exports an `activate` function. All preloads are evaluated before any [renderer scripts](https://code.visualstudio.com/api/extension-guides/notebook#notebook-renderer).

### Notebook renderers can access all output items

[Custom notebook renderers](https://code.visualstudio.com/api/extension-guides/notebook#notebook-renderer) can now access all MIME data of the output item it is rendering. If the renderer determines that it cannot render the main output item properly, this API proposal lets it fall back to render one of the other MIME types instead.

The entrypoint of this proposal is a new `OutputItem._allOutputItems` property. The property is an ordered list of all MIME types that the current output item contains. Each item in the list has the shape `{ mime, getItem() }`. `mime` is the MIME type such as `text/html` or `image/png`, while the `getItem()` function returns a promise to an `OutputItem` for that MIME type.

Here's how a renderer can use this new api:

```ts
async function renderOutputItem(outputInfo, element, signal){
    const didRender = tryRenderMainItem(outputInfo, element);

    if (!didRender) {
        // Fallback to render `text/html`
        const htmlItem = await outputInfo._allOutputItems.find(item => item.mime === 'text/html')?.getItem();
        if (htmlItem) {
            // Here we can either render the 'text/html' item ourselves or delegate to another renderer
            const renderer = await ctx.getRenderer('vscode.builtin-renderer');
            if (renderer) {
                return renderer.renderOutputItem(htmlItem, element, signal);
            }
        }
    }
}
```

Give this proposal a try and let us know what you think!

### Extension Telemetry API

To further drive telemetry best practices and enhance the telemetry features extensions have offered to them, this iteration introduces the proposed `telemetryLogger` API. This API allows extension to supply a `TelemetryAppender`, which acts as the core sending logic (implemented utilizing [Application Insights](https://learn.microsoft.com/azure/azure-monitor/app/create-new-resource) or another data recording service). This `TelemetryAppender` is then used to instantiate a `TelemetryLogger`, which is the class that you should log telemetry through. The `TelemetryLogger` provides a shared output channel to see sent telemetry events, proper telemetry setting checks, and personally identifiable information cleaning. Additionally any errors thrown by utilizing the VS Code API will be logged to your appender for better error diagnostics. There is a simple example in the [telemetry sample](https://github.com/microsoft/vscode-extension-samples/blob/d7dd9da34a9849396719408716d468512b5e5abb/telemetry-sample/src/extension.ts) and you can provide feedback in [issue #160090](https://github.com/microsoft/vscode/issues/160090).

## Engineering

### Optimizing for input latency

As VS Code has grown in size, so has the amount of things we do when a keystroke is pressed. This iteration we stepped back and did a thorough investigation into what exactly happens when you type in the editor and what can we defer until after the keystroke is rendered on screen. The main outcomes of this exploration were:

* Several changes were made to defer as much work as possible until after a keystroke in the editor has been rendered on screen. A rough estimate of the impact of this is a ~15% reduction in input latency when intellisense is not showing, and an even higher reduction when intellisense is being refiltered.
* We now have more refined techniques for manually measuring input latency and optimizing at this sub-millisecond\* level.
* There is a work in progress change that will help us track and report samples of input latency, this will give us some concrete number to maintain and improve against.

This is just the beginning of this effort and we have more changes that should land next release.

\* _These numbers are very dependent upon the hardware that is used to test. A 0.5ms improvement on powerful hardware may end up being 2ms on more average hardware._

### Automatic renderer profiling

The renderer-process of VS Code is responsible for its UI, it ensures a blinking cursor, the ability to type, and to save. Any performance issue in the renderer-process will be visible to the user and is equal to a bad experience. To help us identify and fix performance issues in the renderer-process, we have added a new setting `application.experimental.rendererProfiling` that can be used to automatically profile the renderer-process. The setting can be set to `on` to enable profiling, and `off` to disable profiling. When enabled, the renderer-process will be profiled for a few seconds whenever it "appears as pressured", the profile is then analyzed, anonymized, and sent off for inspection. You can use the window log to follow along with the profiling process.

Note that this feature is currently off by default as we still learn and tune things. Please try it out and let us know what you think.

## Notable fixes

* [153852](https://github.com/microsoft/vscode/issues/153852) Proposal: Remove ES5 Class Compatibility to speed up Extension APIs
* [158921](https://github.com/microsoft/vscode/issues/158921) Settings Modified Elsewhere indicator hover content overflows
* [156104](https://github.com/microsoft/vscode/issues/156104) Don't auto-forward port on url link click, if it's already statically forwarded
* [151019](https://github.com/microsoft/vscode/issues/151019) Debug hover is hiding when hovered

<a id="scroll-to-top" role="button" title="Scroll to top" aria-label="scroll to top" href="#"><span class="icon"></span></a>
<link rel="stylesheet" type="text/css" href="css/inproduct_releasenotes.css"/>

## Thank you

Last but certainly not least, a big _**Thank You**_ to the contributors of VS Code.

### Issue tracking

Contributions to our issue tracking:

* [John Murray (@gjsjohnmurray)](https://github.com/gjsjohnmurray)
* [Simon Chan (@yume-chan)](https://github.com/yume-chan)
* [Andrii Dieiev (@IllusionMH)](https://github.com/IllusionMH)
* [ArturoDent (@ArturoDent)](https://github.com/ArturoDent)
* [RedCMD (@RedCMD)](https://github.com/RedCMD)
